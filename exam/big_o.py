"""
BIG O

CONTENT
    1. Big O Notation
    2. Sequential Statements
    3. Conditional Statements
    4. Loop Statements
    5. Nested loops statements
    6. Function call statements
    7. Recursive Functions Statements
    8. Examples

"""

# 1. Big O Notation
"""
Big-O notation is a metric used to find an algorithms complexity. Big-O notation signifies the 
relationship between the input to the algorithm, and the steps/operations required to execute the algorithm. 

When we count the operations taken by algorithms, we don't really care about one-off operations (constants factors); 
we care about actions that are related to the size of the input, n. For a list, that's the number of elements; 
for a string, it can be the number of characters. All that matters is the dominant term (the highest power of n). 

The Big O notation for f(n) can be derived from the following simplification rules:
    - If f(n) is a sum of several terms, we keep only the one with largest growth rate.
        In order best to worst Big-O complexity: 1 < log n < n < n log n < n^2 < 2^n < n!
    - If f(n) is a product of several factors, any constant factors is omitted.


In order from smallest to largest complexity:
Constant Time: O(1)
Logarithmic Time: O(log n)
Linear Time: O(n)
Linearithmic Time: O(n log n)
Quadric Time: O(n^2)
Cubic TIme: O(n^3)
Plynomial TIme: O(n^k)
Exponential Time: O(b^n)
Factorial Time: O(n!)
"""

# 2. Sequential Statements


# 3. Conditional Statements


# 4. Loops


# 5. Nested loops


# 6. Function calls


# 7. Recursive Functions


# 8. More examples
